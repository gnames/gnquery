package parser

// Code generated by peg query.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleQuery
	ruleTail
	ruleComponents
	ruleElement
	ruleNameVal
	ruleDSVal
	ruleAllVal
	ruleSpeciesAnyVal
	ruleSpeciesInfraVal
	ruleSpeciesVal
	ruleTaxonVal
	ruleAuVal
	ruleGenusVal
	ruleYearVal
	ruleAuthor
	ruleDataSources
	ruleAllMatches
	ruleAllBestResults
	ruleGenus
	ruleNameString
	ruleParentTaxon
	ruleSpecies
	ruleSpeciesAny
	ruleSpeciesInfra
	ruleYear
	ruleYearRange
	ruleYearNum
	ruleNumbers
	ruleNumber
	ruleBool
	ruleDigits
	ruleCaps
	ruleWord
	rule_
	ruleMultipleSpace
	ruleSingleSpace
	ruleEND
)

var rul3s = [...]string{
	"Unknown",
	"Query",
	"Tail",
	"Components",
	"Element",
	"NameVal",
	"DSVal",
	"AllVal",
	"SpeciesAnyVal",
	"SpeciesInfraVal",
	"SpeciesVal",
	"TaxonVal",
	"AuVal",
	"GenusVal",
	"YearVal",
	"Author",
	"DataSources",
	"AllMatches",
	"AllBestResults",
	"Genus",
	"NameString",
	"ParentTaxon",
	"Species",
	"SpeciesAny",
	"SpeciesInfra",
	"Year",
	"YearRange",
	"YearNum",
	"Numbers",
	"Number",
	"Bool",
	"Digits",
	"Caps",
	"Word",
	"_",
	"MultipleSpace",
	"SingleSpace",
	"END",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type engine struct {
	Buffer string
	buffer []rune
	rules  [38]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *engine) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *engine) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *engine
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *engine) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *engine) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *engine) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*engine) error {
	return func(p *engine) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*engine) error {
	return func(p *engine) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *engine) Init(options ...func(*engine) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Query <- <(_? Components Tail END)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					if !_rules[rule_]() {
						goto l2
					}
					goto l3
				l2:
					position, tokenIndex = position2, tokenIndex2
				}
			l3:
				if !_rules[ruleComponents]() {
					goto l0
				}
				if !_rules[ruleTail]() {
					goto l0
				}
				if !_rules[ruleEND]() {
					goto l0
				}
				add(ruleQuery, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Tail <- <(_ .*)?> */
		func() bool {
			{
				position5 := position
				{
					position6, tokenIndex6 := position, tokenIndex
					if !_rules[rule_]() {
						goto l6
					}
				l8:
					{
						position9, tokenIndex9 := position, tokenIndex
						if !matchDot() {
							goto l9
						}
						goto l8
					l9:
						position, tokenIndex = position9, tokenIndex9
					}
					goto l7
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
			l7:
				add(ruleTail, position5)
			}
			return true
		},
		/* 2 Components <- <(Element (_ Element)*)> */
		func() bool {
			position10, tokenIndex10 := position, tokenIndex
			{
				position11 := position
				if !_rules[ruleElement]() {
					goto l10
				}
			l12:
				{
					position13, tokenIndex13 := position, tokenIndex
					if !_rules[rule_]() {
						goto l13
					}
					if !_rules[ruleElement]() {
						goto l13
					}
					goto l12
				l13:
					position, tokenIndex = position13, tokenIndex13
				}
				add(ruleComponents, position11)
			}
			return true
		l10:
			position, tokenIndex = position10, tokenIndex10
			return false
		},
		/* 3 Element <- <((NameString NameVal) / (DataSources DSVal) / (Year YearVal) / (AllMatches AllVal) / (AllBestResults AllVal) / (Genus GenusVal) / (Species SpeciesVal) / (SpeciesInfra SpeciesInfraVal) / (SpeciesAny SpeciesAnyVal) / (Author AuVal) / (ParentTaxon TaxonVal))> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				{
					position16, tokenIndex16 := position, tokenIndex
					if !_rules[ruleNameString]() {
						goto l17
					}
					if !_rules[ruleNameVal]() {
						goto l17
					}
					goto l16
				l17:
					position, tokenIndex = position16, tokenIndex16
					if !_rules[ruleDataSources]() {
						goto l18
					}
					if !_rules[ruleDSVal]() {
						goto l18
					}
					goto l16
				l18:
					position, tokenIndex = position16, tokenIndex16
					if !_rules[ruleYear]() {
						goto l19
					}
					if !_rules[ruleYearVal]() {
						goto l19
					}
					goto l16
				l19:
					position, tokenIndex = position16, tokenIndex16
					if !_rules[ruleAllMatches]() {
						goto l20
					}
					if !_rules[ruleAllVal]() {
						goto l20
					}
					goto l16
				l20:
					position, tokenIndex = position16, tokenIndex16
					if !_rules[ruleAllBestResults]() {
						goto l21
					}
					if !_rules[ruleAllVal]() {
						goto l21
					}
					goto l16
				l21:
					position, tokenIndex = position16, tokenIndex16
					if !_rules[ruleGenus]() {
						goto l22
					}
					if !_rules[ruleGenusVal]() {
						goto l22
					}
					goto l16
				l22:
					position, tokenIndex = position16, tokenIndex16
					if !_rules[ruleSpecies]() {
						goto l23
					}
					if !_rules[ruleSpeciesVal]() {
						goto l23
					}
					goto l16
				l23:
					position, tokenIndex = position16, tokenIndex16
					if !_rules[ruleSpeciesInfra]() {
						goto l24
					}
					if !_rules[ruleSpeciesInfraVal]() {
						goto l24
					}
					goto l16
				l24:
					position, tokenIndex = position16, tokenIndex16
					if !_rules[ruleSpeciesAny]() {
						goto l25
					}
					if !_rules[ruleSpeciesAnyVal]() {
						goto l25
					}
					goto l16
				l25:
					position, tokenIndex = position16, tokenIndex16
					if !_rules[ruleAuthor]() {
						goto l26
					}
					if !_rules[ruleAuVal]() {
						goto l26
					}
					goto l16
				l26:
					position, tokenIndex = position16, tokenIndex16
					if !_rules[ruleParentTaxon]() {
						goto l14
					}
					if !_rules[ruleTaxonVal]() {
						goto l14
					}
				}
			l16:
				add(ruleElement, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 4 NameVal <- <(GenusVal _ SpeciesVal (_ SpeciesInfraVal)? (_ AuVal)? (_ YearVal)?)> */
		func() bool {
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				if !_rules[ruleGenusVal]() {
					goto l27
				}
				if !_rules[rule_]() {
					goto l27
				}
				if !_rules[ruleSpeciesVal]() {
					goto l27
				}
				{
					position29, tokenIndex29 := position, tokenIndex
					if !_rules[rule_]() {
						goto l29
					}
					if !_rules[ruleSpeciesInfraVal]() {
						goto l29
					}
					goto l30
				l29:
					position, tokenIndex = position29, tokenIndex29
				}
			l30:
				{
					position31, tokenIndex31 := position, tokenIndex
					if !_rules[rule_]() {
						goto l31
					}
					if !_rules[ruleAuVal]() {
						goto l31
					}
					goto l32
				l31:
					position, tokenIndex = position31, tokenIndex31
				}
			l32:
				{
					position33, tokenIndex33 := position, tokenIndex
					if !_rules[rule_]() {
						goto l33
					}
					if !_rules[ruleYearVal]() {
						goto l33
					}
					goto l34
				l33:
					position, tokenIndex = position33, tokenIndex33
				}
			l34:
				add(ruleNameVal, position28)
			}
			return true
		l27:
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 5 DSVal <- <Numbers> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				if !_rules[ruleNumbers]() {
					goto l35
				}
				add(ruleDSVal, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 6 AllVal <- <Bool> */
		func() bool {
			position37, tokenIndex37 := position, tokenIndex
			{
				position38 := position
				if !_rules[ruleBool]() {
					goto l37
				}
				add(ruleAllVal, position38)
			}
			return true
		l37:
			position, tokenIndex = position37, tokenIndex37
			return false
		},
		/* 7 SpeciesAnyVal <- <Word> */
		func() bool {
			position39, tokenIndex39 := position, tokenIndex
			{
				position40 := position
				if !_rules[ruleWord]() {
					goto l39
				}
				add(ruleSpeciesAnyVal, position40)
			}
			return true
		l39:
			position, tokenIndex = position39, tokenIndex39
			return false
		},
		/* 8 SpeciesInfraVal <- <Word> */
		func() bool {
			position41, tokenIndex41 := position, tokenIndex
			{
				position42 := position
				if !_rules[ruleWord]() {
					goto l41
				}
				add(ruleSpeciesInfraVal, position42)
			}
			return true
		l41:
			position, tokenIndex = position41, tokenIndex41
			return false
		},
		/* 9 SpeciesVal <- <Word> */
		func() bool {
			position43, tokenIndex43 := position, tokenIndex
			{
				position44 := position
				if !_rules[ruleWord]() {
					goto l43
				}
				add(ruleSpeciesVal, position44)
			}
			return true
		l43:
			position, tokenIndex = position43, tokenIndex43
			return false
		},
		/* 10 TaxonVal <- <(Caps Word)> */
		func() bool {
			position45, tokenIndex45 := position, tokenIndex
			{
				position46 := position
				if !_rules[ruleCaps]() {
					goto l45
				}
				if !_rules[ruleWord]() {
					goto l45
				}
				add(ruleTaxonVal, position46)
			}
			return true
		l45:
			position, tokenIndex = position45, tokenIndex45
			return false
		},
		/* 11 AuVal <- <(Caps Word?)> */
		func() bool {
			position47, tokenIndex47 := position, tokenIndex
			{
				position48 := position
				if !_rules[ruleCaps]() {
					goto l47
				}
				{
					position49, tokenIndex49 := position, tokenIndex
					if !_rules[ruleWord]() {
						goto l49
					}
					goto l50
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
			l50:
				add(ruleAuVal, position48)
			}
			return true
		l47:
			position, tokenIndex = position47, tokenIndex47
			return false
		},
		/* 12 GenusVal <- <(Caps Word)> */
		func() bool {
			position51, tokenIndex51 := position, tokenIndex
			{
				position52 := position
				if !_rules[ruleCaps]() {
					goto l51
				}
				if !_rules[ruleWord]() {
					goto l51
				}
				add(ruleGenusVal, position52)
			}
			return true
		l51:
			position, tokenIndex = position51, tokenIndex51
			return false
		},
		/* 13 YearVal <- <(YearRange / YearNum)> */
		func() bool {
			position53, tokenIndex53 := position, tokenIndex
			{
				position54 := position
				{
					position55, tokenIndex55 := position, tokenIndex
					if !_rules[ruleYearRange]() {
						goto l56
					}
					goto l55
				l56:
					position, tokenIndex = position55, tokenIndex55
					if !_rules[ruleYearNum]() {
						goto l53
					}
				}
			l55:
				add(ruleYearVal, position54)
			}
			return true
		l53:
			position, tokenIndex = position53, tokenIndex53
			return false
		},
		/* 14 Author <- <('a' 'u' ':')> */
		func() bool {
			position57, tokenIndex57 := position, tokenIndex
			{
				position58 := position
				if buffer[position] != rune('a') {
					goto l57
				}
				position++
				if buffer[position] != rune('u') {
					goto l57
				}
				position++
				if buffer[position] != rune(':') {
					goto l57
				}
				position++
				add(ruleAuthor, position58)
			}
			return true
		l57:
			position, tokenIndex = position57, tokenIndex57
			return false
		},
		/* 15 DataSources <- <('d' 's' ':')> */
		func() bool {
			position59, tokenIndex59 := position, tokenIndex
			{
				position60 := position
				if buffer[position] != rune('d') {
					goto l59
				}
				position++
				if buffer[position] != rune('s') {
					goto l59
				}
				position++
				if buffer[position] != rune(':') {
					goto l59
				}
				position++
				add(ruleDataSources, position60)
			}
			return true
		l59:
			position, tokenIndex = position59, tokenIndex59
			return false
		},
		/* 16 AllMatches <- <('a' 'l' 'l' ':')> */
		func() bool {
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				if buffer[position] != rune('a') {
					goto l61
				}
				position++
				if buffer[position] != rune('l') {
					goto l61
				}
				position++
				if buffer[position] != rune('l') {
					goto l61
				}
				position++
				if buffer[position] != rune(':') {
					goto l61
				}
				position++
				add(ruleAllMatches, position62)
			}
			return true
		l61:
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 17 AllBestResults <- <('a' 'b' 'r' ':')> */
		func() bool {
			position63, tokenIndex63 := position, tokenIndex
			{
				position64 := position
				if buffer[position] != rune('a') {
					goto l63
				}
				position++
				if buffer[position] != rune('b') {
					goto l63
				}
				position++
				if buffer[position] != rune('r') {
					goto l63
				}
				position++
				if buffer[position] != rune(':') {
					goto l63
				}
				position++
				add(ruleAllBestResults, position64)
			}
			return true
		l63:
			position, tokenIndex = position63, tokenIndex63
			return false
		},
		/* 18 Genus <- <(('g' 'e' 'n' ':') / ('g' ':'))> */
		func() bool {
			position65, tokenIndex65 := position, tokenIndex
			{
				position66 := position
				{
					position67, tokenIndex67 := position, tokenIndex
					if buffer[position] != rune('g') {
						goto l68
					}
					position++
					if buffer[position] != rune('e') {
						goto l68
					}
					position++
					if buffer[position] != rune('n') {
						goto l68
					}
					position++
					if buffer[position] != rune(':') {
						goto l68
					}
					position++
					goto l67
				l68:
					position, tokenIndex = position67, tokenIndex67
					if buffer[position] != rune('g') {
						goto l65
					}
					position++
					if buffer[position] != rune(':') {
						goto l65
					}
					position++
				}
			l67:
				add(ruleGenus, position66)
			}
			return true
		l65:
			position, tokenIndex = position65, tokenIndex65
			return false
		},
		/* 19 NameString <- <('n' ':')> */
		func() bool {
			position69, tokenIndex69 := position, tokenIndex
			{
				position70 := position
				if buffer[position] != rune('n') {
					goto l69
				}
				position++
				if buffer[position] != rune(':') {
					goto l69
				}
				position++
				add(ruleNameString, position70)
			}
			return true
		l69:
			position, tokenIndex = position69, tokenIndex69
			return false
		},
		/* 20 ParentTaxon <- <('t' 'x' ':')> */
		func() bool {
			position71, tokenIndex71 := position, tokenIndex
			{
				position72 := position
				if buffer[position] != rune('t') {
					goto l71
				}
				position++
				if buffer[position] != rune('x') {
					goto l71
				}
				position++
				if buffer[position] != rune(':') {
					goto l71
				}
				position++
				add(ruleParentTaxon, position72)
			}
			return true
		l71:
			position, tokenIndex = position71, tokenIndex71
			return false
		},
		/* 21 Species <- <('s' 'p' ':')> */
		func() bool {
			position73, tokenIndex73 := position, tokenIndex
			{
				position74 := position
				if buffer[position] != rune('s') {
					goto l73
				}
				position++
				if buffer[position] != rune('p') {
					goto l73
				}
				position++
				if buffer[position] != rune(':') {
					goto l73
				}
				position++
				add(ruleSpecies, position74)
			}
			return true
		l73:
			position, tokenIndex = position73, tokenIndex73
			return false
		},
		/* 22 SpeciesAny <- <('a' 's' 'p' ':')> */
		func() bool {
			position75, tokenIndex75 := position, tokenIndex
			{
				position76 := position
				if buffer[position] != rune('a') {
					goto l75
				}
				position++
				if buffer[position] != rune('s') {
					goto l75
				}
				position++
				if buffer[position] != rune('p') {
					goto l75
				}
				position++
				if buffer[position] != rune(':') {
					goto l75
				}
				position++
				add(ruleSpeciesAny, position76)
			}
			return true
		l75:
			position, tokenIndex = position75, tokenIndex75
			return false
		},
		/* 23 SpeciesInfra <- <('i' 's' 'p' ':')> */
		func() bool {
			position77, tokenIndex77 := position, tokenIndex
			{
				position78 := position
				if buffer[position] != rune('i') {
					goto l77
				}
				position++
				if buffer[position] != rune('s') {
					goto l77
				}
				position++
				if buffer[position] != rune('p') {
					goto l77
				}
				position++
				if buffer[position] != rune(':') {
					goto l77
				}
				position++
				add(ruleSpeciesInfra, position78)
			}
			return true
		l77:
			position, tokenIndex = position77, tokenIndex77
			return false
		},
		/* 24 Year <- <(('y' 'r' ':') / ('y' ':'))> */
		func() bool {
			position79, tokenIndex79 := position, tokenIndex
			{
				position80 := position
				{
					position81, tokenIndex81 := position, tokenIndex
					if buffer[position] != rune('y') {
						goto l82
					}
					position++
					if buffer[position] != rune('r') {
						goto l82
					}
					position++
					if buffer[position] != rune(':') {
						goto l82
					}
					position++
					goto l81
				l82:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('y') {
						goto l79
					}
					position++
					if buffer[position] != rune(':') {
						goto l79
					}
					position++
				}
			l81:
				add(ruleYear, position80)
			}
			return true
		l79:
			position, tokenIndex = position79, tokenIndex79
			return false
		},
		/* 25 YearRange <- <(('-' YearNum) / (YearNum '-' YearNum?))> */
		func() bool {
			position83, tokenIndex83 := position, tokenIndex
			{
				position84 := position
				{
					position85, tokenIndex85 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l86
					}
					position++
					if !_rules[ruleYearNum]() {
						goto l86
					}
					goto l85
				l86:
					position, tokenIndex = position85, tokenIndex85
					if !_rules[ruleYearNum]() {
						goto l83
					}
					if buffer[position] != rune('-') {
						goto l83
					}
					position++
					{
						position87, tokenIndex87 := position, tokenIndex
						if !_rules[ruleYearNum]() {
							goto l87
						}
						goto l88
					l87:
						position, tokenIndex = position87, tokenIndex87
					}
				l88:
				}
			l85:
				add(ruleYearRange, position84)
			}
			return true
		l83:
			position, tokenIndex = position83, tokenIndex83
			return false
		},
		/* 26 YearNum <- <(('1' / '2') ('0' / '7' / '8' / '9') Digits Digits)> */
		func() bool {
			position89, tokenIndex89 := position, tokenIndex
			{
				position90 := position
				{
					position91, tokenIndex91 := position, tokenIndex
					if buffer[position] != rune('1') {
						goto l92
					}
					position++
					goto l91
				l92:
					position, tokenIndex = position91, tokenIndex91
					if buffer[position] != rune('2') {
						goto l89
					}
					position++
				}
			l91:
				{
					position93, tokenIndex93 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l94
					}
					position++
					goto l93
				l94:
					position, tokenIndex = position93, tokenIndex93
					if buffer[position] != rune('7') {
						goto l95
					}
					position++
					goto l93
				l95:
					position, tokenIndex = position93, tokenIndex93
					if buffer[position] != rune('8') {
						goto l96
					}
					position++
					goto l93
				l96:
					position, tokenIndex = position93, tokenIndex93
					if buffer[position] != rune('9') {
						goto l89
					}
					position++
				}
			l93:
				if !_rules[ruleDigits]() {
					goto l89
				}
				if !_rules[ruleDigits]() {
					goto l89
				}
				add(ruleYearNum, position90)
			}
			return true
		l89:
			position, tokenIndex = position89, tokenIndex89
			return false
		},
		/* 27 Numbers <- <(Number (',' Number)*)> */
		func() bool {
			position97, tokenIndex97 := position, tokenIndex
			{
				position98 := position
				if !_rules[ruleNumber]() {
					goto l97
				}
			l99:
				{
					position100, tokenIndex100 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l100
					}
					position++
					if !_rules[ruleNumber]() {
						goto l100
					}
					goto l99
				l100:
					position, tokenIndex = position100, tokenIndex100
				}
				add(ruleNumbers, position98)
			}
			return true
		l97:
			position, tokenIndex = position97, tokenIndex97
			return false
		},
		/* 28 Number <- <[0-9]+> */
		func() bool {
			position101, tokenIndex101 := position, tokenIndex
			{
				position102 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l101
				}
				position++
			l103:
				{
					position104, tokenIndex104 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l104
					}
					position++
					goto l103
				l104:
					position, tokenIndex = position104, tokenIndex104
				}
				add(ruleNumber, position102)
			}
			return true
		l101:
			position, tokenIndex = position101, tokenIndex101
			return false
		},
		/* 29 Bool <- <(('t' 'r' 'u' 'e') / 't' / ('f' 'a' 'l' 's' 'e') / 'f')> */
		func() bool {
			position105, tokenIndex105 := position, tokenIndex
			{
				position106 := position
				{
					position107, tokenIndex107 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l108
					}
					position++
					if buffer[position] != rune('r') {
						goto l108
					}
					position++
					if buffer[position] != rune('u') {
						goto l108
					}
					position++
					if buffer[position] != rune('e') {
						goto l108
					}
					position++
					goto l107
				l108:
					position, tokenIndex = position107, tokenIndex107
					if buffer[position] != rune('t') {
						goto l109
					}
					position++
					goto l107
				l109:
					position, tokenIndex = position107, tokenIndex107
					if buffer[position] != rune('f') {
						goto l110
					}
					position++
					if buffer[position] != rune('a') {
						goto l110
					}
					position++
					if buffer[position] != rune('l') {
						goto l110
					}
					position++
					if buffer[position] != rune('s') {
						goto l110
					}
					position++
					if buffer[position] != rune('e') {
						goto l110
					}
					position++
					goto l107
				l110:
					position, tokenIndex = position107, tokenIndex107
					if buffer[position] != rune('f') {
						goto l105
					}
					position++
				}
			l107:
				add(ruleBool, position106)
			}
			return true
		l105:
			position, tokenIndex = position105, tokenIndex105
			return false
		},
		/* 30 Digits <- <[0-9]> */
		func() bool {
			position111, tokenIndex111 := position, tokenIndex
			{
				position112 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l111
				}
				position++
				add(ruleDigits, position112)
			}
			return true
		l111:
			position, tokenIndex = position111, tokenIndex111
			return false
		},
		/* 31 Caps <- <([A-Z] / 'À' / 'Á' / 'Â' / 'Ã' / 'Ä' / 'Å' / 'Æ' / 'Ç' / 'È' / 'É' / 'Ê' / 'Ë' / 'Ì' / 'Í' / 'Î' / 'Ï' / 'Ð' / 'Ñ' / 'Œ' / 'Ò' / 'Ó' / 'Ô' / 'Õ' / 'Ö' / 'Ø' / 'Ù' / 'Ú' / 'Û' / 'Ü' / 'Ý' / 'Ć' / 'Č' / 'Ď' / 'İ' / 'Ķ' / 'Ĺ' / 'ĺ' / 'Ľ' / 'ľ' / 'Ł' / 'ł' / 'Ņ' / 'Ō' / 'Ő' / 'Œ' / 'Ř' / 'Ś' / 'Ŝ' / 'Ş' / 'Š' / 'Ÿ' / 'Ź' / 'Ż' / 'Ž' / 'ƒ' / 'Ǿ' / 'Ș' / 'Ț')> */
		func() bool {
			position113, tokenIndex113 := position, tokenIndex
			{
				position114 := position
				{
					position115, tokenIndex115 := position, tokenIndex
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l116
					}
					position++
					goto l115
				l116:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('À') {
						goto l117
					}
					position++
					goto l115
				l117:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Á') {
						goto l118
					}
					position++
					goto l115
				l118:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Â') {
						goto l119
					}
					position++
					goto l115
				l119:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ã') {
						goto l120
					}
					position++
					goto l115
				l120:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ä') {
						goto l121
					}
					position++
					goto l115
				l121:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Å') {
						goto l122
					}
					position++
					goto l115
				l122:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Æ') {
						goto l123
					}
					position++
					goto l115
				l123:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ç') {
						goto l124
					}
					position++
					goto l115
				l124:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('È') {
						goto l125
					}
					position++
					goto l115
				l125:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('É') {
						goto l126
					}
					position++
					goto l115
				l126:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ê') {
						goto l127
					}
					position++
					goto l115
				l127:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ë') {
						goto l128
					}
					position++
					goto l115
				l128:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ì') {
						goto l129
					}
					position++
					goto l115
				l129:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Í') {
						goto l130
					}
					position++
					goto l115
				l130:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Î') {
						goto l131
					}
					position++
					goto l115
				l131:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ï') {
						goto l132
					}
					position++
					goto l115
				l132:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ð') {
						goto l133
					}
					position++
					goto l115
				l133:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ñ') {
						goto l134
					}
					position++
					goto l115
				l134:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Œ') {
						goto l135
					}
					position++
					goto l115
				l135:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ò') {
						goto l136
					}
					position++
					goto l115
				l136:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ó') {
						goto l137
					}
					position++
					goto l115
				l137:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ô') {
						goto l138
					}
					position++
					goto l115
				l138:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Õ') {
						goto l139
					}
					position++
					goto l115
				l139:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ö') {
						goto l140
					}
					position++
					goto l115
				l140:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ø') {
						goto l141
					}
					position++
					goto l115
				l141:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ù') {
						goto l142
					}
					position++
					goto l115
				l142:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ú') {
						goto l143
					}
					position++
					goto l115
				l143:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Û') {
						goto l144
					}
					position++
					goto l115
				l144:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ü') {
						goto l145
					}
					position++
					goto l115
				l145:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ý') {
						goto l146
					}
					position++
					goto l115
				l146:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ć') {
						goto l147
					}
					position++
					goto l115
				l147:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Č') {
						goto l148
					}
					position++
					goto l115
				l148:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ď') {
						goto l149
					}
					position++
					goto l115
				l149:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('İ') {
						goto l150
					}
					position++
					goto l115
				l150:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ķ') {
						goto l151
					}
					position++
					goto l115
				l151:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ĺ') {
						goto l152
					}
					position++
					goto l115
				l152:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('ĺ') {
						goto l153
					}
					position++
					goto l115
				l153:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ľ') {
						goto l154
					}
					position++
					goto l115
				l154:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('ľ') {
						goto l155
					}
					position++
					goto l115
				l155:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ł') {
						goto l156
					}
					position++
					goto l115
				l156:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('ł') {
						goto l157
					}
					position++
					goto l115
				l157:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ņ') {
						goto l158
					}
					position++
					goto l115
				l158:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ō') {
						goto l159
					}
					position++
					goto l115
				l159:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ő') {
						goto l160
					}
					position++
					goto l115
				l160:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Œ') {
						goto l161
					}
					position++
					goto l115
				l161:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ř') {
						goto l162
					}
					position++
					goto l115
				l162:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ś') {
						goto l163
					}
					position++
					goto l115
				l163:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ŝ') {
						goto l164
					}
					position++
					goto l115
				l164:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ş') {
						goto l165
					}
					position++
					goto l115
				l165:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Š') {
						goto l166
					}
					position++
					goto l115
				l166:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ÿ') {
						goto l167
					}
					position++
					goto l115
				l167:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ź') {
						goto l168
					}
					position++
					goto l115
				l168:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ż') {
						goto l169
					}
					position++
					goto l115
				l169:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ž') {
						goto l170
					}
					position++
					goto l115
				l170:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('ƒ') {
						goto l171
					}
					position++
					goto l115
				l171:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ǿ') {
						goto l172
					}
					position++
					goto l115
				l172:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ș') {
						goto l173
					}
					position++
					goto l115
				l173:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('Ț') {
						goto l113
					}
					position++
				}
			l115:
				add(ruleCaps, position114)
			}
			return true
		l113:
			position, tokenIndex = position113, tokenIndex113
			return false
		},
		/* 32 Word <- <(!([A-Z] / [1-9] / '-' / ':' / ' ') . (!([1-9] / ':' / ' ') .)* &(_ / END))> */
		func() bool {
			position174, tokenIndex174 := position, tokenIndex
			{
				position175 := position
				{
					position176, tokenIndex176 := position, tokenIndex
					{
						position177, tokenIndex177 := position, tokenIndex
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l178
						}
						position++
						goto l177
					l178:
						position, tokenIndex = position177, tokenIndex177
						if c := buffer[position]; c < rune('1') || c > rune('9') {
							goto l179
						}
						position++
						goto l177
					l179:
						position, tokenIndex = position177, tokenIndex177
						if buffer[position] != rune('-') {
							goto l180
						}
						position++
						goto l177
					l180:
						position, tokenIndex = position177, tokenIndex177
						if buffer[position] != rune(':') {
							goto l181
						}
						position++
						goto l177
					l181:
						position, tokenIndex = position177, tokenIndex177
						if buffer[position] != rune(' ') {
							goto l176
						}
						position++
					}
				l177:
					goto l174
				l176:
					position, tokenIndex = position176, tokenIndex176
				}
				if !matchDot() {
					goto l174
				}
			l182:
				{
					position183, tokenIndex183 := position, tokenIndex
					{
						position184, tokenIndex184 := position, tokenIndex
						{
							position185, tokenIndex185 := position, tokenIndex
							if c := buffer[position]; c < rune('1') || c > rune('9') {
								goto l186
							}
							position++
							goto l185
						l186:
							position, tokenIndex = position185, tokenIndex185
							if buffer[position] != rune(':') {
								goto l187
							}
							position++
							goto l185
						l187:
							position, tokenIndex = position185, tokenIndex185
							if buffer[position] != rune(' ') {
								goto l184
							}
							position++
						}
					l185:
						goto l183
					l184:
						position, tokenIndex = position184, tokenIndex184
					}
					if !matchDot() {
						goto l183
					}
					goto l182
				l183:
					position, tokenIndex = position183, tokenIndex183
				}
				{
					position188, tokenIndex188 := position, tokenIndex
					{
						position189, tokenIndex189 := position, tokenIndex
						if !_rules[rule_]() {
							goto l190
						}
						goto l189
					l190:
						position, tokenIndex = position189, tokenIndex189
						if !_rules[ruleEND]() {
							goto l174
						}
					}
				l189:
					position, tokenIndex = position188, tokenIndex188
				}
				add(ruleWord, position175)
			}
			return true
		l174:
			position, tokenIndex = position174, tokenIndex174
			return false
		},
		/* 33 _ <- <(MultipleSpace / SingleSpace)> */
		func() bool {
			position191, tokenIndex191 := position, tokenIndex
			{
				position192 := position
				{
					position193, tokenIndex193 := position, tokenIndex
					if !_rules[ruleMultipleSpace]() {
						goto l194
					}
					goto l193
				l194:
					position, tokenIndex = position193, tokenIndex193
					if !_rules[ruleSingleSpace]() {
						goto l191
					}
				}
			l193:
				add(rule_, position192)
			}
			return true
		l191:
			position, tokenIndex = position191, tokenIndex191
			return false
		},
		/* 34 MultipleSpace <- <(SingleSpace SingleSpace+)> */
		func() bool {
			position195, tokenIndex195 := position, tokenIndex
			{
				position196 := position
				if !_rules[ruleSingleSpace]() {
					goto l195
				}
				if !_rules[ruleSingleSpace]() {
					goto l195
				}
			l197:
				{
					position198, tokenIndex198 := position, tokenIndex
					if !_rules[ruleSingleSpace]() {
						goto l198
					}
					goto l197
				l198:
					position, tokenIndex = position198, tokenIndex198
				}
				add(ruleMultipleSpace, position196)
			}
			return true
		l195:
			position, tokenIndex = position195, tokenIndex195
			return false
		},
		/* 35 SingleSpace <- <' '> */
		func() bool {
			position199, tokenIndex199 := position, tokenIndex
			{
				position200 := position
				if buffer[position] != rune(' ') {
					goto l199
				}
				position++
				add(ruleSingleSpace, position200)
			}
			return true
		l199:
			position, tokenIndex = position199, tokenIndex199
			return false
		},
		/* 36 END <- <!.> */
		func() bool {
			position201, tokenIndex201 := position, tokenIndex
			{
				position202 := position
				{
					position203, tokenIndex203 := position, tokenIndex
					if !matchDot() {
						goto l203
					}
					goto l201
				l203:
					position, tokenIndex = position203, tokenIndex203
				}
				add(ruleEND, position202)
			}
			return true
		l201:
			position, tokenIndex = position201, tokenIndex201
			return false
		},
	}
	p.rules = _rules
	return nil
}
