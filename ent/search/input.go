package search

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/gnames/gnparser"
	"github.com/gnames/gnparser/ent/parsed"
	"github.com/gnames/gnquery/ent/tag"
)

// Input contains data needed for creating a faceted search query by
// GNames.
type Input struct {
	// Query field keep the search query parsed to form the input structure.
	Query string `json:"input,omitempty"`

	// Warnings field contains warnings generated by a parsing process.
	Warnings []string `json:"warnings,omitempty"`

	// DataSourceID field contains data-source ID for ParentTaxon and
	// serves as a preferred data-source in the final search results.
	DataSourceID int `json:"dataSourceID,omitempty"`

	// ParentTaxon creates a filter to return only results that have the
	// required taxon in their classification path. The field uses DataSourceID
	// to get information which data-source to use. If none is set, it will
	// use Catalogue of Life (ID = 1).
	ParentTaxon string `json:"parentTaxon,omitempty"`

	// NameString is a convenience field. It allows to provide faceted search
	// data as a freeform 'name-string' input. The name-string does not have
	// to be a 'real name', and it suppose to have only one component of each
	// kind. For example it should contain one infraspecific epithet, and
	// one author. If it has more, a warning will be generated and only one
	// of the values of a ducplicated category will be used.
	//
	// For example: `Aus bus cus A. 1888`.
	//
	// If NameString is given, all other inputs for genus, species,
	// authors, year will be ignored.
	NameString string `json:"nameString,omitempty"`

	// Genus field creates a faceted search filter by a genus name. The name
	// can be abbreviated up to one character following a period.
	//
	// For example: `H.`, `Hom.`, `Homo`.
	Genus string `json:"genus,omitempty"`

	// SpeciesAny field creates a faceted search filter for either specific or
	// infraspecific epithets. If SpeciesAny is given Species and SpeciesInfra
	// fields are ignored.
	SpeciesAny string `json:"speciesAny,omitempty"`

	// Species field creates a faceted search filter for specific epithet only.
	Species string `json:"species,omitempty"`

	// SpecieInfra field creates a faceted search filter for infraspecific
	// epithets. Such epithets can be subspecies, varieties, formas etc.
	SpeciesInfra string `json:"speciesInfra,omitempty"`

	// Author field creates a faceted search filter for Author name. This
	// field can be abbreviated up to one letter folloing period character.
	//
	// For example: `L.`, `Linn.`, `Linnaeus`.
	Author string `json:"author,omitempty"`

	// Year field creates a faceted search filter for a year.
	Year int `json:"year,omitempty"`

	// YearRange field creates a more flexible filter for year data.
	//
	// Example:
	// 1990-1995: year >= 1990 && year =< 1995
	// 1990-: year >= 1990
	// -1995: year <= 1995
	*YearRange `json:"yearRange,omitempty"`

	// Tail field keeps a non-parsed pard of a query, in case if full parsing
	// of query string did fail.
	Tail string `json:"tail,omitempty"`
}

// YearRange field creates a more flexible filter for year data.
//
// Example:
// 1990-1995: year >= 1990 && year =< 1995
// 1990-: year >= 1990
// -1995: year <= 1995
type YearRange struct {
	// YearStart is the smaller year of the range.
	// YearEnd is the larger year of the range.
	YearStart, YearEnd int
}

// ProcessName checks if NameString is given in the Input object.
// If yes, it cleans up redundant fields and populates data from a parsed
// name-string.
func (q Input) ProcessName() Input {
	if q.NameString == "" {
		return q
	}

	res := Input{Query: q.Query, NameString: q.NameString,
		Tail: q.Tail, Warnings: q.Warnings,
		DataSourceID: q.DataSourceID, ParentTaxon: q.ParentTaxon,
	}

	cfg := gnparser.NewConfig(gnparser.OptWithDetails(true))
	p := gnparser.New(cfg)
	pRes := p.ParseName(q.NameString)

	if !pRes.Parsed {
		res.Warnings = append(res.Warnings, "Cannot parse '%s'", q.NameString)
		return res
	}

	for _, v := range pRes.Words {
		val := v.Normalized
		switch v.Type {
		case parsed.GenusType:
			res.Genus = val
		case parsed.SpEpithetType:
			res.Species = val
		case parsed.InfraspEpithetType:
			res.SpeciesInfra = val
		case parsed.AuthorWordType:
			res.Author = val
		case parsed.YearType:
			res.Year, _ = strconv.Atoi(val)
		}
	}
	return res
}

type qTags struct {
	tag tag.Tag
	val string
}

func (q Input) ToQuery() string {
	if q.Query != "" {
		return q.Query
	}

	qSlice := make([]string, 0, 9)

	var ds string
	if val := strconv.Itoa(q.DataSourceID); val != "0" {
		ds = val
	}

	data1 := []qTags{
		{tag.DataSourceID, ds},
		{tag.ParentTaxon, q.ParentTaxon},
		{tag.NameString, q.NameString},
	}

	qSlice = processTags(qSlice, data1)

	if q.NameString != "" {
		return strings.Join(qSlice, " ")
	}

	var yr, yrStart, yrEnd string
	if val := strconv.Itoa(q.Year); val != "0" {
		yr = val
	}

	if q.YearRange != nil {
		if q.YearStart > 0 {
			yrStart = strconv.Itoa(q.YearStart)
		}
		if q.YearEnd > 0 {
			yrEnd = strconv.Itoa(q.YearEnd)
		}
		yr = fmt.Sprintf("%s-%s", yrStart, yrEnd)
	}

	data2 := []qTags{
		{tag.Genus, q.Genus},
		{tag.Species, q.Species},
		{tag.SpeciesInfra, q.SpeciesInfra},
		{tag.SpeciesAny, q.SpeciesAny},
		{tag.Author, q.Author},
		{tag.Year, yr},
	}

	qSlice = processTags(qSlice, data2)

	return strings.Join(qSlice, " ")
}

func processTags(qSlice []string, data []qTags) []string {
	for _, v := range data {
		if v.val != "" {
			str := v.tag.String() + ":" + v.val
			qSlice = append(qSlice, str)
		}
	}
	return qSlice
}
